리액트 18에서 도입된 기능으로 클라이언트 측과 서버 측의 렌더링 방식을 분리하여 성능과 개발자 경험을 개선하려는 목적을 가지고 있음(현재 실험적인 상태에서 제공)

## 주요 동작 방식

### 1. 서버에서 렌더링

- 서버 컴포넌트는 서버에서 렌더링, 즉, 서버에서 HTML을 생성하고 그 결과를 클라이언트로 보내는 방식
- 서버에서 실행되는 컴포넌트는 상태를 서버에서 관리할 수 있으며 클라이언트에서 복잡한 데이터 fetching이나 계산을 하지 않아도 됨
- 서버 컴포넌트는 클라이언트 번들에 포함되지 않으며 이를 통해 클라이언트 측 로딩 시간을 줄이고 초기 렌더링 성능을 향상시킬 수 있음

### 2. 클라이언트와 서버 컴포넌트의 분리

- 서버 컴포넌트는 클라이언트 측과 완전히 분리되어 클라이언트에서는 서버에서 렌더링된 결과물만 받아서 표시
- 클라이언트 컴포넌트와 서버 컴포넌트가 서로 혼합될 수 있는데, 클라이언트 컴포넌트는 상호작용 및 이벤트 처리 등을 담당하고 서버 컴포넌트는 렌더링 및 데이터 fetching을 담당

### 3. 데이터 fetching을 서버에서 처리

- 서버 컴포넌트는 클라이언트에서 데이터 요청을 처리할 필요 없이 필요한 데이터를 서버에서 가져올 수 있음, 이를 통해 데이터 fetching이 클라이언트 측에서 일어나는 것보다 성능 면에서 더 효율적일 수 있음
- 서버에서 데이터를 처리한 후 그 결과만 클라이언트로 보내기 때문에 불필요한 클라이언트 측 렌더링을 피할 수 있음

### 4. 재사용성

- 서버 컴포넌트는 상태를 포함하고 있는 서버 전용 로직을 처리할 수 있으며 클라이언트에서는 사용할 필요가 없는 복잡한 비즈니스 로직을 서버 측에서 처리
- 이러한 컴포넌트는 클라이언트 번들에 포함되지 않으므로 전체 애플리케이션의 크기를 줄이고 성능을 최적화하는 데 기여할 수 있음

### 5. 인터렉티브 클라이언트 컴포넌트와 혼합

- 서버 컴포넌트는 클라이언트 컴포넌트와 상호작용할 수 있음, 예를 들어 서버에서 렌더링된 HTML을 클라이언트에서 받아서 해당 HTML을 바탕으로 상호작용 가능한 컴포넌트로 변환할 수 있음
- 클라이언트에서 상호작용이 필요한 부분은 여전히 클라이언트 컴포넌트로 처리됨, 예를 들어 버튼 클릭, 폼 제출, 상태 업데이트 등은 클라이언트 측에서만 발생하도록 할 수 있음

## 서버 컴포넌트의 장점

### 1. 성능 최적화

- 서버에서 렌더링되므로 클라이언트에서 필요 없는 자바스크립트 코드가 실행되지 않으며, 클라이언트 측 렌더링을 최소화할 수 있음
- 클라이언트가 초기 페이지를 로딩하는 데 필요한 데이터를 미리 서버에서 처리하고 결과를 전달하기 때문에 초기 로딩 성능이 크게 향상됨

### 2. 데이터 처리 최적화

- 서버 컴포넌트는 서버에서 데이터를 직접 fetching하거나 비즈니스 로직을 처리하므로 클라이언트에서 데이터를 처리하는 것보다 더 효율적일 수 있
- 클라이언트에 불필요한 데이터를 전달하지 않고, 필요한 정보만을 클라이언트로 전송할 수 있음

### 3. 클라이언트 번들 크기 감소

- 서버에서만 사용되는 컴포넌트는 클라이언트 번들에 포함되지 않기 때문에 애플리케이션의 클라이언트 번들 크기를 줄여 성능을 최적화할 수 있음

## 서버 컴포넌트의 한계

### 1. 상호작용 처리의 한계

- 서버 컴포넌트는 기본적으로 상호작용을 처리하지 않음, 즉, 서버에서 렌더링된 HTML은 클라이언트의 상호작용을 처리할 수 없으며 상호작용이 필요한 부분은 클라이언트 컴포넌트로 처리해야 함
- 예를 들어 버튼 클릭, 폼 입력 등의 이벤트는 클라이언트 컴포넌트에서 처리해야 함

### 2. 실험적 기능

- 리액트 서버 컴포넌트는 실험적인 기능이므로 아직 공식적으로 안정화된 상태는 아님, 따라서 실무에서 사용하기에는 일부 제한이 있을 수 있음

### 3. 서버 사이드 렌더링(SSR)과 혼동될 수 있음

- 서버 컴포넌트와 SSR(Server-Side Rendering)은 다름
- SSR은 서버에서 전체 페이지를 렌더링하여 HTML을 보내는 방식인 반면 서버 컴포넌트는 특정 컴포넌트를 서버에서만 렌더링하여 클라이언트에 전달하는 방식

## 예시

```
// Server Component (server.js)
import React from 'react';

export default function UserList() {
  const users = fetchUsersFromDatabase(); // 서버에서 데이터 fetching

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Client Component (client.js)
import React from 'react';

export default function ClientApp() {
  return (
    <div>
      <h1>Welcome to our app!</h1>
      <UserList /> {/* 서버 컴포넌트 렌더링 */}
    </div>
  );
}
```

## vs SSR

| 특징                     | 서버 컴포넌트(Server Components)          | SSR(Server-Side Rendering)           |
|--------------------------|------------------------------------------|--------------------------------------|
| **렌더링 단위**          | 컴포넌트 단위로 서버 렌더링                | 전체 페이지를 서버에서 렌더링          |
| **JS 번들**              | 클라이언트로 전달되지 않음                 | 클라이언트로 HTML + JS 번들 전달       |
| **데이터 전송**           | 최소 데이터와 UI만 클라이언트로 전송        | 전체 HTML과 번들 데이터 전송          |
| **초기 로딩 속도**        | 빠름 (번들 크기 감소)                     | 빠름 (서버에서 HTML 생성)             |
| **SEO 지원**             | 지원                                    | 지원                                 |
| **서버 부하**             | 상대적으로 낮음                          | 요청당 렌더링으로 서버 부하 높음       |
| **복잡도**               | 높음 (서버/클라이언트 컴포넌트 구분 필요) | 낮음 (일반적인 SSR 방식)              |
| **주요 사용 사례**        | React 18 이상 기반 애플리케이션           | 전통적인 SSR 기반 애플리케이션         |
